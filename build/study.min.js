/**
 * studyjs - A client side A/B tester
 * @version v2.0.0
 * @link https://github.com/dollarshaveclub/study
 * @author Jacob Kelley <jacob.kelley@dollarshaveclub.com>
 * @license MIT */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Study = factory());
}(this, (function () { 'use strict';

var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set$1 = function set$1(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set$1(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

var isServer = !!(typeof module !== 'undefined' && module.exports);
var storageKey = 'ab-tests';
var rand = function rand(min, max) {
  return Math.random() * (max - min + min);
};

var chooseWeightedItem = function chooseWeightedItem(names, weights) {
  // Total out the number of weights
  var total = weights.reduce(function (a, b) {
    return a + b;
  });
  var limit = 0;

  // Get a random number between 0 and the total number of weights
  var n = rand(0, total);

  // Loop until we've encountered the first weight greater than our random number
  for (var i = 0; i < names.length; i += 1) {
    limit += weights[i];

    if (n <= limit) {
      return names[i];
    }
  }
  return '';
};

/**
 * Formats providedTests to be consumed by the end developer
 * @param  {Array} providedTests List of tests
 * @return {Array|Object}        An array or object depending on the length of providedTests
 */
var response = function response(tests) {
  return tests.length === 1 ? tests[0] : tests;
};

var Study = function () {

  /**
   * The Study constructor. Initializes the store, tests, and restores persisted user buckets
   * @type {Function}
   */
  function Study() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$store = _ref.store,
        store = _ref$store === undefined ? Study.stores.local : _ref$store;

    classCallCheck(this, Study);

    this.store = store;
    this.userBuckets = {};
    this.userAssignments = {};
    this.providedTests = [];

    var userBuckets = this.store.get(storageKey);
    if (userBuckets) {
      try {
        this.userBuckets = JSON.parse(userBuckets);
      } catch (e) {}
    }
  }

  /**
   * Define a single or multiple tests
   * @param {Object} data An object or an array of objects containing the test
   * info such as name and buckets
   */


  createClass(Study, [{
    key: 'define',
    value: function define(data) {
      var _this = this;

      var normalizedData = data;
      if (!Array.isArray(data)) {
        normalizedData = [data];
      }

      normalizedData.forEach(function (test) {
        if (!test.name) {
          throw new Error('Tests must have a name');
        }
        if (!test.buckets) {
          throw new Error('Tests must have buckets');
        }
        if (!Object.keys(test.buckets)) {
          throw new Error('Tests must have buckets');
        }
        _this.providedTests = _this.providedTests.concat(test);
      });
    }

    /**
     * Return all defined tests
     * @return {Array} Formatted/provided tests
     */

  }, {
    key: 'definitions',
    value: function definitions() {
      return response(this.providedTests);
    }

    /**
     * Executes the bucketing of all provided tests. Will bucket a user if the
     * query string is set, then falls back to restoring a persisted bucket, then
     * falls back to determining a bucket for the user.
     * @type {Function}
     * @param {Boolean} isDry If true, will not persist test buckets
     */

  }, {
    key: 'assign',
    value: function assign(testName, bucketName) {
      var _this2 = this;

      var oldAssignments = this.assignments();
      this.userAssignments = {};
      this.providedTests.forEach(function (test) {
        var shouldPersist = test.name in _this2.userBuckets;
        var shouldBucket = bucketName && testName && testName === test.name;
        var shouldSkipTest = testName && test.name !== testName;
        var shouldRemoveBucket = bucketName === null;
        var bucket = void 0;

        // Don't bucket a different test if we're specifying one
        if (shouldSkipTest) return;

        // Specify bucket
        if (shouldRemoveBucket) {
          bucket = bucketName;
        } else if (shouldBucket) {
          // Restore a persisted bucket
          bucket = bucketName;
        } else if (shouldPersist) {
          // Restore a persisted bucket
          bucket = _this2.userBuckets[test.name];
        } else {
          (function () {
            // Determine Bucket
            var names = Object.keys(test.buckets);
            var weights = [];

            names.forEach(function (bucketName) {
              if (typeof test.buckets[bucketName].weight == 'undefined') {
                test.buckets[bucketName].weight = 1;
              }
              weights.push(test.buckets[bucketName].weight);
            });
            bucket = chooseWeightedItem(names, weights);
          })();
        }

        if (shouldRemoveBucket) {
          console.log("REMOVING");
          if (!isServer) {
            document.body.classList.remove(test.name + '--' + oldAssignments[test.name]);
          }
          delete _this2.userAssignments[test.name];
        } else {
          // Add to our assignments
          if (!isServer) {
            document.body.classList.add(test.name + '--' + bucket);
          }
          _this2.userAssignments[test.name] = bucket;
        }
      });
      // console.log(testName, this.userAssignments);
      // Persist buckets
      this.persist(this.userAssignments);
    }

    /**
     * Fetch all of the buckets belonging to a user
     * @type {Function}
     * @return {Object} Object whose keys are test names and values are the buckets
     * a user has been placed in
     */

  }, {
    key: 'assignments',
    value: function assignments() {
      return this.userAssignments;
    }

    /**
     * Saves information in the store to be retrieved at a later point
     * @type {Function}
     * @param {Object} data The data to save to the store
     */

  }, {
    key: 'persist',
    value: function persist(data) {
      this.store.set(storageKey, JSON.stringify(data));
    }

    /**
     * An object housing all of the different stores available to us
     * @type {Object}
     */

  }]);
  return Study;
}();

Study.stores = {
  local: {
    get: function get(key) {
      return localStorage.getItem(key);
    },
    set: function set(key, val) {
      return localStorage.setItem(key, val);
    }
  }
};

return Study;

})));
